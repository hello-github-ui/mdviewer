> 装饰器本质上就是一个闭包函数，装饰器的返回值也是一个函数对象。
>
> 它可以让其它函数在不需要做任何代码变动的前提下增加额外功能。

**装饰器的理解**：

实质：是一个函数

参数：是你要装饰的函数名（并非函数调用）

返回：是装饰完的函数名（也非函数调用）

作用：为已经存在的对象添加额外的功能

特点：不需要对对象做任何的代码上的变动

应用场景：函数执行时间的统计、可以用在框架的路由传参上、插入日志、事务处理、权限校验、缓存。

> **装饰器的使用方法：**
>
> 1. 先定义一个装饰函数（帽子），也可以用类、偏函数实现；
> 2. 再定义你的业务函数或者类（人） --这是真正要执行的函数
> 3. 最后把这顶帽子戴在这个人头上去
>
> 装饰器的语法糖用法：`@装饰器名称`，同样可以完成对已有函数的装饰操作。
>
> `@intro` 这个语法相当于执行：`hello = intro(eat)`，为 eat 函数装饰并返回。

**装饰器的标准模板：**

```python
def wrapper(func):
    def inner(*args, **kwargs):
        # 此处可选预留：目标函数执行之前的操作，即额外装饰的操作
        res = func(*args, **kwargs)
        # 此处可选预留：目标函数执行之后的操作
        return res
    return inner
```

* 装饰器-日志打印器

```python
def logger(func):
    def wrapper(*args):
        print(f'准备开始计算:{func.__name__}函数了~~~')
        res = func(*args)
        print(f'{func.__name__}函数已经计算完毕。。。')
        return res # 目标函数add有返回值，则装饰器中必须返回，否则调用add函数后返回None

    return wrapper  # 外层函数返回内层函数的名称


@logger
def add(a, b):
    return a + b


print(add(1, 3))
```

输出：

```
准备开始计算:add函数了~~~
add函数已经计算完毕。。。
4
```

